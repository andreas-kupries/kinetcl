## -*- tcl -*-
# # ## ### ##### ######## #############

## This file defines helper commands used at build-time within the C
## code generation. These commands are not available at runtime, and
## shouldn't be. They are similar to the Publish and MixCapabilities
## commands in policy_base.

## Here we provide setup of common constructions found in and shared
## by the C classes. Common instance variables, their construction,
## etc.

# # ## ### ##### ######## #############

proc kt_class_common {} {
    uplevel 1 {
	introspect-methods
	# auto instance method 'methods'.
	# auto classvar 'methods'
	# auto field    'class'
	# auto instance method 'destroy'.

	include XnOpenNI.h
	# # ## ### ##### ######## #############

	classvar kinetcl_context_data context    {Global kinetcl context, shared by all}
	classvar XnContext*           onicontext {Global OpenNI context, shared by all}
	# # ## ### ##### ######## #############

	classconstructor {
	    kinetcl_context_data c; /* The package's global (per-interp) data */

	    /* Get the framework context. Might fail. */
	    c = kinetcl_context (interp);
	    if (!c) {
		goto error;
	    }

	    class->context    = c;
	    class->onicontext = c->context;
	}

	# # ## ### ##### ######## #############
	## C-level special method. Link the Tcl-level wrapper object
	## to the C-level isntance so that callbacks generated by it
	## carry the proper instance command.

	field Tcl_Obj* self {Self object, can be set to wrapper, see @self}

	constructor {} {
	    instance->self = fqn;
	    Tcl_IncrRefCount (instance->self);

fprintf (stdout,"%u @ %s = (%p) [%p]\n", pthread_self(), Tcl_GetString (instance->self), instance, instance->handle);fflush(stdout);
return;
	}

	mdef @self { /* @self obj */
	    Tcl_DecrRefCount (instance->self);
	    instance->self = objv [2];
	    Tcl_IncrRefCount (instance->self);
	    return TCL_OK;
	}

	# # ## ### ##### ######## #############
    }
}

proc kt_abstract_class {{construction {}} {destruction {}}} {
    uplevel 1 [string map [list \
			       @@construction@@ $construction \
			       @@destruction@@  $destruction \
			      ] {
	::kt_class_common
	# # ## ### ##### ######## #############

	field kinetcl_context_data context    {Global kinetcl context, shared by all}
	field XnContext*           onicontext {Global OpenNI context, shared by all}
	# # ## ### ##### ######## #############

	field XnNodeHandle         handle     {Our handle of the OpenNI production object}
	# # ## ### ##### ######## #############
	constructor {
	    /* As an abstract base class it does not create its own
	    * XnNodeHandle, but gets it from the concrete leaf class.
	    * Which is expected to stash the handle in the per-interp
	    * structures.
	    */

	    instance->context    = instance->class->context;
	    instance->onicontext = instance->class->onicontext;
	    instance->handle     = instance->context->mark;
	    xnProductionNodeAddRef (instance->handle);

@@construction@@
	}

	# # ## ### ##### ######## #############
	destructor {
@@destruction@@
	    xnProductionNodeRelease (instance->handle);
	}

	# # ## ### ##### ######## #############
      }]
}

proc kt_node_class {construction {destruction {}}} {
    uplevel 1 [string map [list \
			       @@construction@@ $construction \
			       @@destruction@@  $destruction \
			      ] {
	::kt_class_common
	# # ## ### ##### ######## #############

	field kinetcl_context_data context    {Global kinetcl context, shared by all}
	field XnContext*           onicontext {Global OpenNI context, shared by all}
	# # ## ### ##### ######## #############

	field XnNodeHandle     handle     {Our handle of the OpenNI player object}

	# # ## ### ##### ######## #############
	constructor {
	    XnStatus     s; /* Status of various OpenNI operations */
	    XnNodeHandle h; /* The player's object handle */

	    instance->context    = instance->class->context;
	    instance->onicontext = instance->class->onicontext;

@@construction@@

	    CHECK_STATUS_GOTO;

	    /* Fill our structure */
	    instance->handle  = h;

	    /* Stash for use by the super classes. */
	    instance->context->mark = h;
	}

	destructor {
@@destruction@@
	    xnProductionNodeRelease (instance->handle);
	}

	# # ## ### ##### ######## #############
    }]
}

# # ## ### ##### ######## #############
return
